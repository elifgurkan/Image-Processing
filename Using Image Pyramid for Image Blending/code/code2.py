# -*- coding: utf-8 -*-
"""Assignment2_BBM415.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ssAYsOxumHNHPtAFor4Tkhr6krLbx4iB
"""

import cv2
import matplotlib.pyplot as plt
import numpy as np
import scipy.signal

img1 = cv2.imread('apple.png')
img2 = cv2.imread('orange.png')

img1=cv2.cvtColor(img1,cv2.COLOR_BGR2RGB)
plt.imshow(img1)

img2=cv2.cvtColor(img2,cv2.COLOR_BGR2RGB)
plt.imshow(img2)

print(img1.shape)
print(img2.shape)

def generatingKernel(a):
    w_1d = np.array([[0.25 - a/2.0, 0.25, a, 0.25, 0.25 - a/2.0]])
    return np.outer(w_1d, w_1d)

def reduce(image):
    kernel = generatingKernel(0.4)
    convolved = scipy.signal.convolve2d(image, kernel, mode='same')
    reduced = convolved[::2, ::2]
    return reduced

def expand(image):
    upsampled = np.zeros((2 * len(image), 2 * len(image[0])))
    upsampled[::2, ::2] = image
    kernel = generatingKernel(0.4)
    convolved = scipy.signal.convolve2d(upsampled, kernel, mode='same')
    expanded = convolved * 4
    return expanded

def gaussPyramid(image, levels):
    output = [image]
    for i in range(levels):
        output.append(reduce(output[i]))
    return output

levels = 5  # number of levels in the pyramid

def display_gauss_pyramids(image, levels, title):
    gauss_pyr = gaussPyramid(image.astype(np.float32) / 255, levels)
    fig, axs = plt.subplots(1, levels+1, figsize=(20, 5))  # levels+1 to include the original image
    for i, ax in enumerate(axs):
        if i == 0:
            ax.imshow(image, cmap='gray')
            ax.set_title(f'{title} Original')
        else:
            ax.imshow(gauss_pyr[i-1], cmap='gray')  # i-1 because gauss_pyr starts from the first reduced level
            ax.set_title(f'{title} Gaussian Level {i}')
        ax.axis('off')
    plt.show()

#  RGB  to grayscale for Gaussian pyramid visualization
img1_gray = cv2.cvtColor(img1, cv2.COLOR_RGB2GRAY)
img2_gray = cv2.cvtColor(img2, cv2.COLOR_RGB2GRAY)

display_gauss_pyramids(img1_gray, levels=5, title='Image 1')
display_gauss_pyramids(img2_gray, levels=5, title='Image 2')

def laplPyramid(gaussPyr):
    output = []
    for i in range(len(gaussPyr)-1):
        expanded = expand(gaussPyr[i+1])
        if expanded.shape[0] != gaussPyr[i].shape[0]:
            expanded = expanded[:gaussPyr[i].shape[0], :]
        if expanded.shape[1] != gaussPyr[i].shape[1]:
            expanded = expanded[:, :gaussPyr[i].shape[1]]
        output.append(gaussPyr[i] - expanded)
    output.append(gaussPyr[-1])
    return output

def display_laplacian_pyramids(image, levels, title):
    laplacian_pyr = laplPyramid(gaussPyramid(image.astype(np.float32) / 255, levels))
    fig, axs = plt.subplots(1, levels, figsize=(20, 5))
    for i, ax in enumerate(axs):
        ax.imshow(laplacian_pyr[i], cmap='gray')
        ax.set_title(f'{title} Laplacian Level {i+1}')
        ax.axis('off')
    plt.show()

display_laplacian_pyramids(img1_gray, levels=5, title='Apple')
display_laplacian_pyramids(img2_gray, levels=5, title='Orange')

def blend(laplPyrWhite, laplPyrBlack, gaussPyrMask):
    blended_pyr = []
    for i in range(len(gaussPyrMask)):
        blended_pyr.append(gaussPyrMask[i]*laplPyrWhite[i] + (1 - gaussPyrMask[i])*laplPyrBlack[i])
    return blended_pyr

def blend_and_display_pyramids(laplPyrWhite, laplPyrBlack, gaussPyrMask):
    blended_pyr = []
    fig, axs = plt.subplots(len(gaussPyrMask), 3, figsize=(15, 5 * len(gaussPyrMask)))

    for i in range(len(gaussPyrMask)):
        blended = gaussPyrMask[i] * laplPyrWhite[i] + (1 - gaussPyrMask[i]) * laplPyrBlack[i]
        blended_pyr.append(blended)

        # white image pyramid level
        axs[i, 0].imshow(laplPyrWhite[i], cmap='gray')
        axs[i, 0].set_title(f'White Laplacian Level {i}')
        axs[i, 0].axis('off')

        # black image pyramid level
        axs[i, 1].imshow(laplPyrBlack[i], cmap='gray')
        axs[i, 1].set_title(f'Black Laplacian Level {i}')
        axs[i, 1].axis('off')

        # blended pyramid level
        axs[i, 2].imshow(blended, cmap='gray')
        axs[i, 2].set_title(f'Blended Level {i}')
        axs[i, 2].axis('off')

    plt.tight_layout()
    plt.show()

    return blended_pyr

gaussPyrImg1_gray = gaussPyramid(img1_gray, levels=5)
gaussPyrImg2_gray = gaussPyramid(img2_gray, levels=5)
laplPyrImg1_gray = laplPyramid(gaussPyrImg1_gray)
laplPyrImg2_gray = laplPyramid(gaussPyrImg2_gray)

mask = np.zeros_like(img1_gray, dtype=np.float32)
mask[:, :mask.shape[1]//2] = 1  # Left half of the mask is 1, right half is 0
gaussPyrMask = gaussPyramid(mask, levels=5)

blended_pyramids = blend_and_display_pyramids(laplPyrImg1_gray, laplPyrImg2_gray, gaussPyrMask)

def collapse(pyramid):
    output = pyramid[-1]
    for i in range(len(pyramid)-1, 0, -1):
        expanded = expand(output)
        if expanded.shape[0] != pyramid[i-1].shape[0]:
            expanded = expanded[:pyramid[i-1].shape[0], :]
        if expanded.shape[1] != pyramid[i-1].shape[1]:
            expanded = expanded[:, :pyramid[i-1].shape[1]]
        output = expanded + pyramid[i-1]
    return output

def blend_images(image1, image2, mask, levels):
    gaussPyrMask = gaussPyramid(mask, levels)
    blended_pyramid = []

    for channel in range(3):
        image1_channel = image1[:, :, channel].astype(np.float32) / 255
        image2_channel = image2[:, :, channel].astype(np.float32) / 255

        gaussPyrImage1 = gaussPyramid(image1_channel, levels)
        gaussPyrImage2 = gaussPyramid(image2_channel, levels)
        laplPyrImage1 = laplPyramid(gaussPyrImage1)
        laplPyrImage2 = laplPyramid(gaussPyrImage2)

        blended_channel = blend(laplPyrImage1, laplPyrImage2, gaussPyrMask)
        blended_channel_collapsed = collapse(blended_channel)
        blended_pyramid.append(blended_channel_collapsed)

    blended_image_rgb = np.stack(blended_pyramid, axis=-1)
    blended_image_rgb = np.clip(blended_image_rgb, 0, 1)
    blended_image_rgb = (blended_image_rgb * 255).astype(np.uint8)

    return blended_image_rgb

img1_color = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB)
img2_color = cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)

mask_rgb = np.zeros_like(img1, dtype=np.float32)
mask_rgb[:, :mask_rgb.shape[1]//2] = 1

blended_rgb_image = blend_images(img1, img2, mask_rgb[:, :, 0], levels=5)

plt.imshow(blended_rgb_image)
plt.axis('off')
plt.show()

final_blended_image = collapse(blended_pyramids)

def plot_frequency_spectrum(image, title):
    # 2-d Fourier transform
    f = np.fft.fft2(image)
    # zero freq component (DC component) to the center
    fshift = np.fft.fftshift(f)
    # magnitude spectrum of the transform
    magnitude_spectrum = 20 * np.log(np.abs(fshift))

    plt.figure(figsize=(10, 7))
    plt.imshow(magnitude_spectrum, cmap='gray')
    plt.title(title)
    plt.axis('off')
    plt.show()

plot_frequency_spectrum(final_blended_image, 'Frequency Spectrum of the Blended Image')

"""The frequency spectrum of the final blended image is displayed above. In this spectrum, the bright region at the center represents the low-frequency components of the image, which correspond to the smooth areas without much detail or sharp transitions. The darker regions away from the center represent the higher frequency components, corresponding to the edges and textures in the image. The symmetry and patterns in the spectrum are indicative of the image's structure and the presence of recurring features at various scales."""

# horizontal line from the middle of the image
signal = final_blended_image[final_blended_image.shape[0] // 2, :]

# sampling of this signal
#sample every 20 pixels to make it visible.
sample_indices = np.arange(0, len(signal), 20)
sampled_signal = signal[sample_indices]

plt.figure(figsize=(14, 8))

# original signal
plt.subplot(2, 1, 1)
plt.plot(signal, label='Original Signal')
plt.legend()

# sampled signal
plt.subplot(2, 1, 2)
plt.stem(sample_indices, sampled_signal, 'r', markerfmt='r.', basefmt=" ", use_line_collection=True, label='Sampled Signal')
plt.legend()

plt.tight_layout()
plt.show()

"""Here's the plot that visualizes the sampling process of the final blended image:

The first plot is the original signal, which represents the intensity values along a horizontal line taken from the middle of the final blended image.
The second plot shows the sampled signal, where red vertical lines represent the intensity values at the sampled points along the same line.
This illustrates how the continuous signal (the original image intensities) is converted into a discrete signal by sampling at regular intervals. ​​
"""